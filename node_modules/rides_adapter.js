/**
 * Rides adapter
 */
var Coordinate = require('coordinate');
var Ride = require('ride');

var RidesAdapter = (function() {
	'use strict'; 
	
	function RidesAdapter(ridesPerDay) {
		this.ridesPerDay = ridesPerDay;
	}
	
	/**
	 * 
	 * @returns {Array}
	 */
	RidesAdapter.prototype.computeRides = function() {	
		var ridesList = [];
		
		// Iterate over each day
		this.ridesPerDay.forEach(function(day) {
			
			// For each day :
			//	- filter malformed traces
			//	- concatenates rides arrays
			day.data.forEach(function(rides) {
				
				// Filter traces without timestamp
				// TODO changed to keep this and used speed 
				// in place of compute speed from time.
				rides = rides.filter(function(trace) {
					return trace.timestamp !== undefined || trace.time !== undefined;
				});
				
				// concatenates rides array
				ridesList = ridesList.concat(rides);
			});
		});
		
		// replace traces by Coordinate objects
		ridesList = ridesList.map(function(trace) {
			return new Coordinate().fromRawTraceObject(trace);
		});
		
		// Split rides based on delay of inactivity
	    var timeWindow = 5; // 5 min
		var allRides = this.splitIntoRides(ridesList, timeWindow);
		
		return allRides;
	};
	
	/**
	 * Split the data set into logical set of coordinate which composed a ride.
	 * This analyze is based over the delay between two coordinate.
	 * 
	 * We also compute some metrics over there.
	 * 
	 * @param data
	 * @param timeWindow
	 * 
	 * @returns Rides list, The Carbon Footprint for this rides list
	 */
	RidesAdapter.prototype.splitIntoRides = function(data, timeWindow) {	
		var rides = [];
		
		rides.push(new Ride());
		for (var i = 1; i < data.length; i++) {
			var t_1 = data[i - 1];	// t-1
			var t = data[i];		// t

			var delta = ((t.timestamp - t_1.timestamp) / 60000).toFixed(2);
			
			/*
			 * Checking if the current position is in 
			 * the current ride or if it's a new ride
			 */
			if (delta > timeWindow) {
				// to overwrite empty rides (less than two points)
				if (rides[rides.length - 1].getLength() > 2) {
					
					// Compute some metrics over the previous ride
					rides[rides.length - 1].computeMetrics();
					
					// Let's got to the next ride!
					rides.push(new Ride());
				}
			}
			
			// add new coordinate
			rides[rides.length - 1].addCoordinate(t);
		}
		
		// remove last if empty
		if (rides[rides.length - 1].getLength() < 2) {
			rides.pop();
		}
		
		// compute metrics on the last element
		if (rides[rides.length - 1]) {
			rides[rides.length - 1].computeMetrics();
		}
		
		return rides;
	};
	
	return RidesAdapter;

}());

module.exports = RidesAdapter;