var Loader = (function() {
	'use strict';

	var fs = require('fs');
	var Coordinate = require('coordinate');
	var Ride = require('ride');

	var Loader = {

		/**
		 * Return a list of rides per user from given file
		 * 
		 * @param filepath
		 * @returns {Array}
		 */
		loadData: function(filepath) {
			console.log('Reading file...');
			var data = fs.readFileSync(filepath, {encoding: 'utf-8'});

			console.log('Parsing JSON data...');
		    var userTraces = this.parseJSONTraces(data);
		    
		    console.log('Spliting data into Rides set...');
		    var timeWindow = 5; // 5 min
		    
		    var userRides = [];
		    userTraces.forEach(function(user) {
				userRides.push(this.splitIntoRides(data, timeWindow));
			});
		    
		    return userRides;
		},
		
		/**
		 * Return a list of users with for each user a list of mobility traces.
		 * 
		 * @param data
		 * @returns {Array}
		 */
		parseJSONTraces: function(data) {
			var tracesListPerUser = [];
		    try {
		    	// JSON processing
			    JSON.parse(data, function(key, value) {
			    	if (key == 'header') {
						return;
					}
			    	
			    	if (key == 'data') {
			    		tracesListPerUser.push(value);
			    		return;
					}
			    	
			    	return value;
				});

			    // Trace object building
			    tracesListPerUser.forEach(function(users) {
					users.forEach(function(value, index, array) {
						// replace traces by Coordinate objects
						array[index] = new Coordinate(
								value['timestamp'],
								value['lon'],
								value['lat'],
								value['accuracy']);
					});
				});

			} catch(e) {
			    console.error('Parsing error:', e); 
			}

			return tracesListPerUser;
		},
		
		/**
		 * Split the data set into logical set of coordinate which composed a ride.
		 * This analyze is based over the delay between two coordinate
		 * 
		 * @param data
		 * @param timeWindow
		 */
		splitIntoRides: function(data, timeWindow) {
			var rides = [];
			rides.push(new Ride());
			for (var i = 1; i < data.length; i++) {
				var t_1 = data[i - 1];	// t-1
				var t = data[i];		// t

				var delta = ((t.timestamp - t_1.timestamp) / 60000).toFixed(2);
				
				/*
				 * Checking if the current position is in 
				 * the current ride or if it's a new ride
				 */
				if (delta > timeWindow) {
					// to overwrite empty rides (less than two points)
					if (rides[rides.length - 1].getLength() > 2) {
						rides.push(new Ride());
					}
				}
				
				// add new coordinate
				rides[rides.length - 1].addCoordinate(t);
			}
			
			return rides;
		}
	};

	return Loader;

}());

module.exports = Loader;